<!DOCTYPE html>
 <html>
 <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <link rel="stylesheet" href="/assets/css/libs/bootstrap.min.css" />
    <link rel="stylesheet" href="/assets/css/libs/ekko-lightbox.css" />
    <link rel="stylesheet" href="/assets/css/libs/highlight.min.css" />
    <link rel="stylesheet" href="/assets/css/style.css" />

    <script src="/assets/js/libs/jquery-3.6.0.min.js"></script>
    <script src="/assets/js/libs/bootstrap.min.js"></script>
    <script src="/assets/js/libs/ekko-lightbox.min.js"></script>
    <script src="/assets/js/libs/highlight.min.js"></script>

    <!--MathJax-->
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async
            src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  
    <meta name="description" content=""/>
    <title>
        
            Podstawy programowania | Notatki z zajęć
        
        Katalog notatek z informatyki stosowanej
    </title>
 </head>
 <body>
    <div class="container" id="main-container">
    <header class="note-section card card-body bg-light">
        <h1>Podstawy programowania (wykłady, semester  1)</h1>
        
            <p style="color: gray; margin-bottom: 8px;">
                Prowadzący: dr inż. Tomasz Marciniak
            </p>
        

        <nav>
            <ul class="nav nav-tabs">
                

                

                

                
        
                
                    <li class="nav-item">
                        <a class="nav-link active" href="/notepage/sem1/lectures/podstawy_programowania/wyk_podstawy_programowania_notatki/">Notatki z zajęć</a>
                    </li>
                
                    <li class="nav-item">
                        <a class="nav-link" href="/notepage/sem1/lectures/podstawy_programowania/wyk_podstawy_programowania_info/">Informacje o zaliczeniu i prowadzącym</a>
                    </li>
                
                    <li class="nav-item">
                        <a class="nav-link" href="/notepage/sem1/lectures/podstawy_programowania/wyk_podstawy_programowania_materialy/">Opracowania i materiały do nauki</a>
                    </li>
                
            </ul>
        </nav>
    
        <p style="margin-top: 20px;"><a href="/">(&larr; powrót do strony głównej)</a></p>
    </header>

    <section class="note-section card card-body bg-light">
    <h1>Garść definicji</h1>

    <div class="note-subsection">
        <strong>Kompilator:</strong>
        <ul>
            <li>program tłumaczący kod źródłowy na inny kod, najczęściej maszynowy</li>
            <li>taki kod maszynowy posiada adresy względne i trzeba go potraktować linkerem, aby dostać program możliwy do odpalenia</li>
        </ul>
    </div>

    <div class="note-subsection">
        <strong>Konsolidator (inaczej linker):</strong>
        <ul>
            <li>program łączący skompilowane "pliki obiektowe" w jeden plik wykonywalny</li>
            <li>dołącza do pliku wykonywalnego biblioteki</li>
            <li>zamienia adresy względne "wyplute" przez kompilator na adresy bezwzględne</li>
        </ul>
    </div>

    <div class="note-subsection">
        <strong>IDE:</strong>
        <ul>
            <li>integrated development environment</li>
            <li>zintegrowane środowisko programistyczne, bardzo ułatwiające programowanie</li>
            <li>przykładowe IDE to PyCharm, CLion i Visual Studio</li>
            <li>nie mylić z dyskami IDE (Integrated Drive Electronics)</li>
        </ul>
    </div>

    <div class="note-subsection">
        <strong>Narzędzia RAD:</strong>
        <ul>
            <li>rapid application development</li>
            <li>narzędzia RAD to rozwinięcie konceptu IDE</li>
            <li>bardzo ułatwiają tworzenie na przykład interfejsów graficznych</li>
            <li>w narzędziach RAD interfejsy graficzne tworzy się metodą przeciągnij-i-upuść</li>
            <li>przykładowe narzędzia RAD to Visual Studio, C++ Builder</li>
        </ul>
    </div>

    <div class="note-subsection">
        <strong>API:</strong>
        <ul>
            <li>application programming interface</li>
            <li>są to polecenia, które można wykorzystywać przy programowaniu</li>
            <li>dzięki ich użyciu, nasz program ma dostęp do pewnych funkcji innego programu</li>
            <li>na przykład dzięki API Allegro możemy stworzyć program, który kupuje coś na Allegro</li>
        </ul>
    </div>

    <div class="note-subsection">
        <strong>Abstrakcja:</strong>
        <p>Abstrakcja polega na wyodrębnieniu i uogólnieniu najważniejszych cech problemu i wyrażeniu rozwiązania właśnie w obrębie tych cech.</p>
    </div>

    <div class="note-subsection">
        <strong>Podejścia w programowaniu:</strong>
        <ul>
            <li>
                <u>podejście proceduralne</u>
                <p>program traktowany jako seria instrukcji i procedur działających na danych</p>
            </li>
            <li>
                <u>podejście strukturalne</u>
                <p>dane odseparowane od działających na nich funkcji</p>
            </li>
            <li>
                <u>podejście obiektowe</u>
                <p>program jest logicznie podzielony na klasy, łączące w jedną całość dane i operujące na nich funkcje</p>
            </li>
        </ul>
    </div>
</section>

<section class="note-section card card-body bg-light">
    <h1>Podstawy C</h1>

    <div class="note-subsection">
        <strong>Typy danych:</strong>

        <ol>
            <li>
                Typy proste
                <ul>
                    <li>int, float, double, bool, char (i ich odmiany)</li>
                    <li>
                        typy specjalne
                        <ul>
                            <li>void - typ nieokreślony, pusty typ danych (używamy go gdy funkcja nie zwraca żadnych danych)</li>
                            <li>wskaźnik - przechowuje adres w pamięci komputera, gdzie znajdują się jakieś określone dane</li>
                            <li>referencja - oznaczana znakiem &amp;, jest to numer jakiejś komórki w pamięci komputera</li>
                        </ul>
                    </li>
                </ul>
            </li>
            <li>
                Typy złożone (składają się z innych typów)
                <ul>
                    <li>struct</li>
                    <li>union</li>
                    <li>class</li>
                    <li>array</li>
                </ul>
            </li>
        </ol>
    </div>

    <div class="note-subsection">
        <strong>Komentarze w C i CPP:</strong>
        <p>Uwaga, komentarzy nie wolno zagnieżdżać!</p>
        <pre><code>
            /*komentarz wielolinijkowy*
            // komentarz jednolinijkowy
        </code></pre>
    </div>

    <div class="note-subsection">
        <strong>Podstawowe biblioteki:</strong>
        <pre><code>
            // standardowe wejście/wyjście
            #include &lt;stdio.h&gt;
            // dodatkowe funkcje wejścia/wyjścia
            #include &lt;conio.h&gt; 
        </code></pre>
    </div>
</section>

<section class="note-section card card-body bg-light">
    <h1>System binarny</h1>

    <div class="note-subsection">
        <strong>Jak komputer przechowuje liczby ujemne?</strong>
        <p>Reprezentacja U2</p>
    </div>

    <div class="note-subsection">
        <strong>Najstarszy i najmłodszy bit</strong>
        <p>Najstarszy bit to najczęściej ten najbardziej po lewej, a najmłodszy najbardziej po prawej.</p>
        <p>Najstarszy jest najważniejszy, bo ma najwyższą wartość. Najmłodszy jest najmniej ważny, bo ma najmniejszą wartość.</p>
        <p><u>10010</u> - 1 jest najstarszym bitem, a 0 najmłodszym</p>
    </div>

    <div class="note-subsection">
        <strong>System liczbowy U2</strong>
        <p>C i C++ używają systemu U2 (kodu uzupełnień do dwóch), aby przechowywać wartości ujemne.</p>
        <p>W takim kodzie najbardziej znaczący bit zawsze przyjmuje wartość ujemną</p>
        <p>Więcej o tym systemie można doczytać tu: <a href="http://www.algorytm.edu.pl/systemy-liczbowe/u2.html" target="_blank">(link do artykułu)</a></p>
        <p>00000010<sub>u2</sub> = 2<sub>dec</sub> (najbardziej znaczący bit to 0, więc liczba dodatnia)</p>
        <p>10000000<sub>u2</sub> = -128<sub>dec</sub> (najbardziej znaczący bit to 1, więc liczba ujemna)</p>
        <p>11111111<sub>u2</sub> = -1<sub>dec</sub> (same jedynki w systemie U2 zawsze oznaczają liczbę -1</p>
    </div>
</section>

<section class="note-section card card-body bg-light">
    <h1>Operatory bitowe</h1>

    <ul>
        <li>a | b</li>
        <li>a & b</li>
        <li>a ^ b</li>
        <li>a &lt;&lt; b</li>
        <li>a &gt;&gt; b</li>
    </ul>
</section>

<section class="note-section card card-body bg-light">
    <h1>Kwalifikatory znaku i długości zmiennych</h1>

    <pre><code>
        signed int x; // typ x ze znakiem, taka zmienna może być dodatnia lub ujemna
        unsigned int xx; // typ x bez znaku, taka zmienna zawsze będzie większa lub równa od zera
        long int xxx; // normalny int jest zwykle 32-bitowy, a long int jest 64-bitowy
        short int xxxx; // normalny int jest zwykle 32-bitowy, a short int jest 16-bitowy

        // zamiast 'signed int' można pisać po prostu 'int'
    </code></pre>

    <p><strong>Uwaga!</strong> Nie powinno się porównywać zmiennych unsigned ze zmiennymi signed.</p>
</section>

<section class="note-section card card-body bg-light">
    <h1>Wczytywanie i wyświetlanie danych z konsoli</h1>

    <div class="note-subsection">
        <strong>Funkcje wymagające dołączenia biblioteki stdio.h</strong>
        <pre><code>
            printf("Drukowanie na ekranie)
            scanf("&d", &nazwazmiennej)  // wcztytywanie danych ze standardowego wejścia i konwersja
            gets(tablica)  // wczytuje stringi ze standardowego wejścia do tablicy
        </code></pre>
    </div>

    <div class="note-subsection">
        <strong>Wybrane modyfikatory funkcji print:</strong>
        <ul>
            <li>%s (znaki)</li>
            <li>%d, %04d (liczba całkowita)</li>
            <li>%f, %.2f, %06.2f (float)</li>
            <li>%x (postać heksadecymalna, hex)</li>
        </ul>
    </div>

    <div class="note-subsection">
        <strong>Znaki specjalne</strong>
        <ul>
            <li>\a dzwonek</li>
            <li>\n nowa linia</li>
            <li>\r carriage return [kursor wraca na początek linii]</li>
            <li>\t tabulator poziomy</li>
            <li>\v tabulator pionowy</li>
        </ul>
    </div>
</section>

<section class="note-section card card-body bg-light">
    <h1>Instrukcje</h1>

    <strong>Trzeba znać zasadę działania następujących instrukcji:</strong>
    <ul>
        <li>if</li>
        <li>switch</li>
        <li>for</li>
        <li>while</li>
        <li>do-while</li>
    </ul>
</section>

<section class="note-section card card-body bg-light">
    <h1>Zmienne i ich rodzaje</h1>

    <div class="note-subsection">
        <strong>Zachowanie zmiennych globalnych:</strong>
        <pre><code>
            int x;
            int main() {
                int y;

                printf("%d", x); // spowoduje wyświetlenie 0 (bo zmienne globalne mają wartości domyślne)
                printf("%d", y); // spowoduje błąd kompilacji, bo podjęto próbę pobrania wartości niezainicjalizowanej zmiennej lokalnej
            }
        </code></pre>
    </div>

    <div class="note-subsection">
        <strong>Zmienne register:</strong>
        <pre><code>
            register int x = 20;
        </code></pre>
        <p>Zmienne typu register z założenia są cały czas przechowywane w rejestrze procesora. W praktyce jest to jednak tylko wskazówka, dla przykładu w Windowsie nie ma możliwości utworzenia zmiennej register.</p>
    </div>

    <div class="note-subsection">
        <strong>Zmienne extern:</strong>
        <pre><code>
            extern int x;
        </code></pre>
        <p>Zmienna typu extern to deklaracja zmiennej globalnej, która znajduje się w jakimś innym pliku.</p>
    </div>

    <div class="note-subsection">
        <strong>Zmienne static:</strong>
        <pre><code>
            static int x;
        </code></pre>
        <p>Zmienna typu static zachowuje swoją wartość w poszczególnych wywołaniach danej funkcji</p>
    </div>
</section>

<section class="note-section card card-body bg-light">
    <h1>Stałe</h1>

    <div class="note-subsection">
        <strong>Przy użyciu dyrektyw preprocesora:</strong>
        <pre><code>#define PI 3.14</code></pre>
    </div>

    <div class="note-subsection">
        <strong>Przy użyciu słowa kluczowego const:</strong>
        <pre><code>const float PI = 3.14;</code></pre>
    </div>
</section>

<section class="note-section card card-body bg-light">
    <h1>Funkcje</h1>

    <div class="note-subsection">
        <strong>Podział funkcji</strong>
        <ol>
            <li>Funkcje globalne</li>
            <li>Funkcje składowe (związane z obiektami jakichś klas)</li>
        </ol>
    </div>

    <div class="note-subsection">
        <strong>Inny podział funkcji</strong>
        <ol>
            <li>Funkcje wbudowane</li>
            <li>Funkcje zdefiniowane przez użytkownika (programistę)</li>
        </ol>
    </div>

    <div class="note-subsection">
        <strong>Deklaracja a definicja</strong>
        <pre><code>
            // to są definicje
            int dodaj(int, int);
            int odejmij(int a, int b);
            
            // to jest deklaracja
            int pomnoz(int a, int b) {return a*b;}
        </code></pre>
        <p>Definicja funkcji to inaczej jej prototyp.</p>
    </div>

    <div class="note-subsection">
        <strong>Makroinstrukcje</strong>

        <p>Makroinstrukcje – dyrektywy preprocesora działające jak funkcje (mogą przyjmować argumenty</p>

        <pre><code>
            #define DANE printf("Podaj dane użyszkodniku")
            #define max(x,y) ((x)>(y)?(x):(y))
        </code></pre>

        <p>Jedna makroinstrukcja może nawet wywoływać drugą</p>

        <p>Makroinstrukcje mogą być wielolinijkowe – wtedy trzeba umieścić znak \ na końcu linijki</p>
    </div>

    <div class="note-subsection">
        <strong>Dwa sposoby przyjmowania argumentów</strong>

        <ol>
            <li>przez wartość - wartość jest kopiowana, metoda działa <strong>na zasadzie zmiennych lokalnych</strong></li>
            <li>przez wskaźnik - przekazujemy wskaźnik, zmienna nie jest kopiowana, a zmiana zmiennej wewnątrz funkcji powduje zmianę zmiennej również na zewnątrz</li>
        </ol>
    </div>
</section>

<section class="note-section card card-body bg-light">
    <h1>Tablice</h1>

    <div class="note-subsection">
        <strong>Tablica jednowymiarowa:</strong>
        <pre><code>int elo[3] = {1, 2, 3};</code></pre>
    </div>

    <div class="note-subsection">
        <strong>Tablica wielowymiarowa:</strong>
        <pre><code>
            int elo[3][4] = {&lcub;1,2, 3, 4}, {3, 4, 5, 6}, {5, 6, 7, 8&rcub;};
            int elo2[2][2] = {1, 2, 3, 4};
        </code></pre>
    </div>

    <div class="note-subsection">
        <strong>O tablicach:</strong>
        <ul>
            <li>Tablica to uporządkowana kolekcja danych jednego typu.</li>
            <li>Tablice mogą być automatic, static i external. Nie mogą być register!!</li>
            <li>Tablice static i globalne są wypełniane zerami (lub ogólnie wartościami domyślnymi).</li>
        </ul>
    </div>

    <div class="note-subsection">
        <strong>Uwaga!</strong>
        <pre><code>
            const int X = 5;
            int elo[X]; // niedozwolone, trzeba użyć #define X 5
        </code></pre>
    </div>
</section>

<section class="note-section card card-body bg-light">
    <h1>Struktury</h1>

    <div class="note-subsection">
        <strong>Jak definiować struktury?</strong>
        <pre><code>
            struct pkt {
                int x;
                int y; 
            };

            struct punkt {
                int x;
                int y;
            } p1, p2;  // zmienne strukturalne (globalne zmienne utworzone na podstawie danej struktury)
        
            p1.x = 20;
        
            struct {
                int x;
                int y;
            } pp11, pp22; // gdy zadeklarowaliśmy zmienne strukturalne, struktura nie musi mieć nazwy
        </code></pre>
        <p>Przy definiowaniu struktury nie można zapomnieć o średniku na końcu nawiasu klamrowego!!</p>
    </div>
</section>

<section class="note-section card card-body bg-light">
    <h1>Wskaźniki</h1>

    <div class="note-subsection">
        <pre><code>
            w = &amp;z  // przypisz do w adres zmiennej z
            z = *w  // przypisz do z wartość, na którą wskazuje wskaźnik w (wyłuskiwanie wartości)
            w++, w--  // zwiększa adres zmiennej, na jaką wskazuje wskaźnk o 1
            w1 == w2 // czy wskaźniki wskazują na te samą zmienną?
            w1 = w2  // podstaw pod w1 adres zmiennej na jaką wskazuje w2
    
            int x = 5;
            printf("%d", sizeof(s));
            // Wszystkie wskaźniki mają ten sam rozmiar.
    
            wsk = 0;
            wsk = NULL;
            wsk = &amp;k;
            wsk = (int*) 25550; // absolutny adres w pamięci
    
            register int x = 20;
            int *wsk = &amp;x; //niepoprawne, zmienne rejestrowe nie mają adresu
        </code></pre>
    </div>

    <div class="note-subsection">
        <strong>Czym jest dereferencja?</strong>
        <pre><code>
            int x = 10;
            int* wsk = &amp;x;

            // Gwiazdka jest operatorem dereferencji
            // Powoduje zamianę wskaźnika (zamianę adresu zmiennej) na wartość przypisaną tej zmiennej
            int y = *wsk; // y = 10
        </code></pre>
    </div>

    <div class="note-subsection">
        <strong>Rozmiar wskaźników</strong>
        <p>Wskaźniki (niezależnie do jakiego typu zmiennej) zawsze mają stały rozmiar. W przypadku aplikacji 32-bitowych rozmiar wskaźnika to 4 bajty.</p>
    </div>
</section>

<section class="note-section card card-body bg-light">
    <h1>Dyrektywy preprocesora</h1>

    <div class="note-subsection">
        <strong>Tworzenie aliasu na typ - dyrektywa typedef</strong>
        <pre><code>
            #typedef unsigned long int uli
            uli liczba1, liczba2; // uli to od teraz skrócony zapis dla unsigned long int
        </code></pre>
    </div>

    <div class="note-subsection">
        <strong>Dołączanie kodu źródłowego - dyrektywa include</strong>
        <pre><code>
            // Dołączenie biblioteki znajdującej się w domyślnym katalogu z bibliotekami
            #include &lt;stdlib.h&gt;

            // Dołączenie kodu źródłowego znajdującego się pod wskazaną ścieżką
            #include "C:\folder\plik.h"

            // Dołączenie kodu źródłowego znajdującego się w katalogu z bieżącym programem
            #include "plik.h"
        </code></pre>
    </div>

    <div class="note-subsection">
        <strong>Definiowanie stałych symbolicznych i makroinstrukcji - dyrektywa define</strong>
        <pre><code>
            // Makroinstrukcja
            #define MAX(x,y) ((x)>(y)?(x

            // Stała symboliczna
            #define PI 3.14

            // Stała bez zdefiniowanej wartości (patrz: podrozdział poniżej)
            #define DEBUG_MODE
        </code></pre>
    </div>

    <div class="note-subsection">
        <strong>Warunkowa kompilacja</strong>
        <p>Warunkowa kompilacja pozwala skompilować wyłącznie wskazane fragmenty kodu. Pozwala to na przykład na programowanie programów wieloplatformowych, w których pewne linijki powinny być kompilowane wyłącznie na pewnych platformach.</p>
        <pre><code>
            #define DEBUG_MODE

            #ifdef DEBUG_MODE
                printf("Debug mode włączony"); 
            #else 
                printf("Debug mode wyłączony");  
            #endif 
        </code></pre>
        <p>Istnieje też dyrektywa #ifndef, będąca zaprzeczeniem dyrektywy #ifdef.</p>
    </div>
</section>

<section class="note-section card card-body bg-light">
    <h1>Unia</h1>
    
    <div class="note-subsection">
        <strong>Jak definować unię?</strong>
        <pre><code>
            union ktk {
                int x;
                float y;
            };

            union zmien {
                int x1;   // 4 bajty
                char zn;  // 1 bajt
            } zm1, zm2; // zmienne globalne, utworzone na podstawie tej unii

            union {
                int x;
                char y;
            } xoxo; // unia nie musi mieć nazwy, jeżeli ma od razu zadeklarowane zmienne
        </code></pre>
        <p>Przy definiowaniu unii nie można zapomnieć o średniku na końcu nawiasu klamrowego!!</p>
    </div>

    <div class="note-subsection">
        <strong>Jak inicjować zmienne przy unii?</strong>
        <pre><code>
            union ktk {
                int x;
                char tab[4];
            } xoxo = {20}; // domyślnie inicjowana wartość jest przypisywana pierwszemu elementowi, w tym przypadku elementowi int x

            union tkt {
                char tab[4];
                int x;
            } oxox = {'a', 'b', 'c', 'd'}; // w tym przypadku inicjujemy tablicę
        </code></pre>
    </div>

    <div class="note-subsection">
        <strong>Czym charakteryzuje się unia?</strong>
        <p>Wszystkie dane unii są przechowywane w tym samym miejscu pamięci.</p>
    </div>

    <div class="note-subsection">
        <strong>Jak wyznaczamy rozmiar unii?</strong>
        <p>Rozmiar unii jest determinowany przez jej największy składnik. Przykładowo poniższa unia posiada wartość int (4 bajty) oraz char (1 bajt). Cała unia ma więc 4 bajty.</p>
        <pre><code>
            union zmien {
                int x1;   // 4 bajty
                char zn;  // 1 bajt
            };
        </code></pre>
    </div>

    <div class="note-subsection">
        <strong>Unia a wartości różnych typów</strong>

        <pre><code>
            // Mamy taką unię o rozmiarze 4 bajtów:
            union ktk {
                int x;
                unsigned char tab[4];
            } xoxo;

            // Bajty tej unii są zapisywane w komputerze w taki sposób:
            [bajt o wadze 256^0] [bajt o wadze 256^1] [bajt o wadze 256^2] [bajt o wadze 256^3]

            // Dokonując na przykład takiego zapisu: 
            xoxo.x = 255

            // Ustawiamy pierwszy bajt na 255, a trzy pozostałe na zero.

            // Dokonując natomiast takiego zapisu:
            xoxo.x = 512

            // Ustawiamy drugi bajt na 2, a wszystkie pozostałe na 0.

            // Gdybyśmy pod xoxo podstawili {10, 0, 0, 8}, to w zmiennej xoxo.x znalazłaby się wartość 10 * 256^0 + 8 * 256^3, czyli 134217738.
        </code></pre>
    </div>    
</section>

<section class="note-section card card-body bg-light">
    <h1>Operacje na plikach w C</h1>

    <div class="note-subsection">
        <strong>Niezbędna biblioteka:</strong>
        <pre><code>
            // Poniższe operacje na plikach wymagają dołączenia biblioteki obsługi standardowego wejścia/wyjścia
            #include &lt;stdio.h&gt;
        </code></pre>
    </div>

    <div class="note-subsection">
        <strong>Otwieranie i zamykanie pliku:</strong>
        <pre><code>
            FILE *f = fopen ("test35.txt", "TRYB_OTWARCIA");
            fclose(f);
        </code></pre>
    </div>

    <div class="note-subsection">
        <strong>Tryby otwarcia:</strong>
        <p>Tryby otwarcia wyszczególnione są: <a href="https://www.cplusplus.com/reference/cstdio/fopen/" target="_blank">[tutaj]</a></p>
    </div>

    <div class="note-subsection">
        <strong>Kontrola błędów:</strong>
        <pre><code>
            FILE *f = fopen("test35.txt", "r"); 
            if(f == NULL) {  
                printf("Nie moge otworzyc pliku");  
            } else { 
                // operacje na pliku 
                fclose(f); 
            }
        </code></pre>
    </div>

    <div class="note-subsection">
        <strong>Funkcje odczytu:</strong>
        <pre><code>
            // fscanf, pozwala na odczyt zmiennych (jak przy scanf)
            fscanf(wskaźnik_do_pliku, "%d", &zmienna_do_ktorej_wczytac);

            // fgets, pozwala na odczyt kolejnych linii pliku
            fgets(tablica_znakow_do_ktorej_wczytac, 100, wskaznik_do_pliku);
            // przy czym 100 to maksymalna liczba znaków, jaką możemy wczytać

            // fgetc, pozwala na odczyt pojedynczych znakow
            fgetc(wskaznik_do_pliku);

            // fread, pozwala na odczyt w trybie binarnym
            fread(&zmienna , sizeof(typ_zmiennej), 1, wskaźnik_do_pliku); // gdzie 1 to ilość elementów, w przypadku tablic będzie to rozmiar tablicy
        </code></pre>
    </div>

    <div class="note-subsection">
        <strong>Funkcje zapisu:</strong>
        <pre><code>
            // fprintf, pozwala na zapis zmiennych (jak przy printf)
            fscanf(wskaźnik_do_pliku, "%d", zmienna_którą_zapisać);

            // fputs, pozwala na zapis całej tablicy znaków
            fputs(tablica_znaków, wskaźnik_do_pliku);

            // fputc, pozwala na zapis pojedynczych znakow
            fputc(znak_do_zapisania, wskaźnik_do_pliku);

            // fwrite, pozwala na zapis w trybie binarnym
            fwrite(&zmienna, sizeof(typ_zmiennej), 1, wskaźnik_do_pliku);  // gdzie 1 to ilość elementów, w przypadku tablic będzie to rozmiar tablicy
        </code></pre>
    </div>

    <p>Więcej o operacjach na plikach w C można przeczytać <a href="https://cybersecurity.umcs.lublin.pl/wp-content/uploads/kmazur/PP2017/lab15.pdf" target="_blank">(tutaj)</a></p>
</section>

<section class="note-section card card-body bg-light">
    <h1>Zmiany w języku C++</h1>

    <div class="note-subsection">
        <strong>Nowe mechanizmy obsługi wejścia/wyjścia</strong>
        <pre><code>
            // wymagana biblioteka
            #include &lt;iostream&gt; 

            int zmienna;
            cin &gt;&gt; zmienna;
            cout &lt;&lt; zmienna;
        </code></pre>
    </div>

    <div class="note-subsection">
        <strong>Dowolne rozmieszczanie deklaracji</strong>
        <p>Zmienne nie muszą już być deklarowane na samym początku funkcji - jedynym wymaganiem jest, aby były one zadeklarowane przed ich pierwszym użyciem.</p>
    </div>

    <div class="note-subsection">
        <strong>Przekazywanie argumentów przez referencję</strong>
        <pre><code>
            void funkcyjka(int &zmienna) {
                zmienna += 10;
            }
        </code></pre>
    </div>

    <div class="note-subsection">
        <strong>Przeciążanie (przeładowanie) funkcji</strong>
        <p>W języku C++, może być kilka funkcji o tej samej nazwie - muszą się różnić listą argumentów lub typem zwracanym.</p>
    </div>

    <div class="note-subsection">
        <strong>Funkcje inline</strong>
        <p>Funkcje inline języka C++ nie powodują faktycznego skoku procesora, a powodują wstawienie danego zestawu instrukcji w miejsce wyołania.</p>
    </div>

    <div class="note-subsection">
        <strong>Dynamiczne zarządzanie pamięcią</strong>
        <p>Do zarządzania pamięcią w C trzeba było używać niewygodnych w użyciu funkcji, takich jak malloc i free. W C++ służą do tego specjalne operatory new oraz delete.</p>
        <pre><code>
            int* wsk = new int;
            int* tabliczka = new int[100];
            delete wsk;
            delete[] tabliczka;
        </code></pre>
    </div>

    <div class="note-subsection">
        <strong>Programowanie obiektowe</strong>
        <p>W C++ mamy do dyspozycji mechanizmy programowania obiektowego - nie było ich w języku C.</p>
    </div>

    <div class="note-subsection">
        <strong>Nowe typy danych</strong>
        <p>long double, wchar_t (wchar oznacza wide char), bool</p>
        <p>pojawia się też typ (czy raczej klasa) string</p>
    </div>
</section>

<section class="note-section card card-body bg-light">
    <h1>Templates (szablony) w języku C++</h1>

    <p>Szablony umożliwiają tworzenie funkcji, które przyjmują i zwracają dane dowolnego typu.</p>

    <pre><code>
        #include &lt;iostream&gt;

        template&lt;class T&gt; void printVariable(T myVariable) {
            std::cout &lt;&lt; myVariable;
        }
        
        int main() {
            printVariable&lt;int&gt;(100);
            return 0;
        }
    </code></pre>
</section>

<section class="note-section card card-body bg-light">
    <h1>Klasy w języku C++</h1>

    <div class="note-subsection">
        <strong>Filary programowania obiektowego</strong>
        <ul>
            <li>
                <u>abstrakcja</u>
                <p>abstrakcja to wolność od konkretnej implementacji; polega na wyodrębnieniu i uogólnieniu najważniejszych cech problemu i wyrażeniu rozwiązania właśnie w obrębie tych cech</p>
            </li>
            <li>
                <u>hermetyzacja (inaczej enkapsulacja)</u>
                <p>polega na ukrywaniu implementacji (przy użyciu słów kluczowych private); uzyskujemy dzięki temu obiekty hermetycznie zamknięte, których nie da się przez przypadek uszkodzić</p>
            </li>
            <li>
                <u>hermetyzacja (inaczej enkapsulacja)</u>
                <p>polega na ukrywaniu implementacji (przy użyciu słów kluczowych private); uzyskujemy dzięki temu obiekty hermetycznie zamknięte, których nie da się przez przypadek uszkodzić</p>
            </li>
            <li>
                <u>polimorfizm </u>
                <p>polimorfizm to inaczej wielopostaciowość; dla przykładu dwie różne klasy mogą mieć metodę drukuj(), która będzie drukowała dane, ale ich implementacje mogą być różne</p>
            </li>
            <li>
                <u>dziedziczenie </u>
                <p>klasy mogą dziedziczyć po sobie, co pozwala na rozszerzanie możliwości obiektu i uniknięcie duplikacji kodu</p>
            </li>
        </ul>
    </div>

    <div class="note-subsection">
        <strong>Domyślny kwantyfikator dostępu</strong>
        <p>Jeśli nie zadeklarowano inaczej, pola w klasie są domyślnie prywatne.</p>
        <pre><code>
            class Point {
                int x, y; // te pola będą prywatne
            };
        </code></pre>
    </div>

    <div class="note-subsection">
        <strong>Dwa sposoby definiowania funkcji</strong><br/>
        <u>Wewnątrz klasy</u>
        <pre><code>
            class Point {
                public:
                void funkcyjka() {
                    std::cout &lt;&lt; "jakas funkcja";
                }
            };
        </code></pre>
        <u>Na zewnątrz klasy</u>
        <pre><code>
            class Point {
                public:
                void funkcyjka();
            };

            void Point::funkcyjka() {
                std::cout &lt;&lt; "jakas funkcja";
            }
        </code></pre>
        <p>W tym pierwszym przypadku (definicja wewnątrz klasy) kompilator automatycznie oznaczy tę funkcję jako inline.</p>
    </div>
</section>

<section class="note-section card card-body bg-light">
    <h1>Dziedziczenie w języku C++</h1>

    <div class="note-subsection">
        <strong>Czego się nie dziedziczy?</strong>
        <ul>
            <li>konstruktorów</li>
            <li>destruktorów</li>
            <li>operatorów przypisania</li>
        </ul>
    </div>

    <div class="note-subsection">
        <strong>Jak zapisywać dziedziczenie?</strong>
        <p>Zwróć uwagę na wywołanie konstruktora bazowego w klasie pochodnej. Jest to wymagane, jeśli klasa bazowa nie posiada konstruktora domyślnego.</p>
        <pre><code>
            class Point {
            public:
                double x, y;
            
                Point(double x, double y) {
                    this->x = x;
                    this->y = y;
                }
            };
                
            class ColoredPoint : public Point {
            public:
                std::string color;
            
                ColoredPoint(double x, double y, std::string color) : Point(x, y) {
                    this->color = color;
                }
            };
        </code></pre>
    </div>

    <div class="note-subsection">
        <strong>Dziedziczenie wielokrotne</strong>
        <p>W języku C++, w odróżnieniu do np. Javy czy C#, klasy pochodne mogą dziedziczyć po kilku klasach bazowych.</p>
        <pre><code>
            class Point3D : public Point, public ColoredPoint { ... }
        </code></pre>
    </div>

    <div class="note-subsection">
        <strong>Rodzaje dziedziczenia</strong><br/>
        <img src="../files/cpp-inheritance.png" alt="dziedziczenie" class="img-fluid" style="width: 60%; border: 1px solid black;" />
    </div>
</section>

<section class="note-section card card-body bg-light">
    <h1>Notacja UML</h1>

    <img src="../files/uml-class.png" alt="uml" class="img-fluid" style="width: 15%; border: 1px solid black;"/>

    <div>
        <p>Trzy sekcje:</p>
        <ul>
            <li>Górna (nazwa klasy)</li>
            <li>Środkowa (właściwości)</li>
            <li>Dolna (metody)</li>
        </ul>
    </div>

    <div>
        <p>Trzy oznaczenia:</p>
        <ul>
            <li># &rarr; składnik protected</li>
            <li>+ &rarr; składnik public</li>
            <li>- &rarr; składnik public</li>
        </ul>
    </div>

</section>

<section class="note-section card card-body bg-light">
    <h1>Typ wyliczeniowy - enum</h1>

    <pre><code>
        enum Color {
            RED=0, GREEN, BLUE=1000, OTHER
        };
    </code></pre>

    <pre><code>
        std::cout &lt;&lt; GREEN; // wyświetli 1
        std::cout &lt;&lt; OTHER; // wyświetli 1001

        Color kolorek; // zmienna która może przyjmować wyłącznie wartości {RED, GREEN, BLUE, OTHER}
    </code></pre>
</section>

<section class="note-section card card-body bg-light">
    <h1>Przeciążanie operatorów</h1>


    <div class="note-subsection">
        <strong>Sposób 1 - poprzez funkcję będącą częścią klasy</strong>
        <pre><code>
            class GeometricalVector {
            public:
                int x, y;
            
                GeometricalVector(int x, int y) {
                    this->x = x;
                    this->y = y;
                }
            
                GeometricalVector operator +(GeometricalVector whatToAdd) {
                    return GeometricalVector(this->x + whatToAdd.x, this->y + whatToAdd.y);
                }
            };
        </code></pre>
    </div>

    <div class="note-subsection">
        <strong>Sposób 2 - poprzez dodatkową funkcję, nie będącą częścią klasy</strong>
        <pre><code>
            class GeometricalVector {
            public:
                int x, y;
            
                GeometricalVector(int x, int y) {
                    this->x = x;
                    this->y = y;
                }
            };
                
            GeometricalVector operator +(GeometricalVector a, GeometricalVector b) {
                return GeometricalVector(a.x + b.x, a.y + b.y);
            }
        </code></pre>
    </div>
</section>

<section class="note-section card card-body bg-light">
    <h1>Przyjaźń</h1>

    <div class="note-subsection">
        <strong>Funkcja zaprzyjaźniona</strong>
        <pre><code>
            class GeometricalVector {
            private:
                int x, y;
            public:
                friend void pokaWektor(GeometricalVector jakisWektor);
            
                GeometricalVector(int x, int y) {
                    this->x = x;
                    this->y = y;
                }
            };
            
            // Funkcja pokaWektor używa prywatnych składowych klasy GeometricalVector
            // bo klasa przyjaźni się z tą funkcją
            void pokaWektor(GeometricalVector jakisWektor) {
                std::cout &lt;&lt; jakisWektor.x &lt;&lt; " " &lt;&lt; jakisWektor.y;
            }
        </code></pre>
    </div>

    <div class="note-subsection">
        <strong>Klasa zaprzyjaźniona</strong>
        <pre><code>
            class GeometricalVector {
            private:
                int x, y;
            public:
                // Klasa JakasCiekawaKlasa będzie mieć dostęp do wszystkich prywatnych składowych klasy GeometricalVector
                friend class JakasCiekawaKlasa;
            
                GeometricalVector(int x, int y) {
                    this->x = x;
                    this->y = y;
                }
            };
        </code></pre>
    </div>
</section>

<section class="note-section card card-body bg-light">
    <h1>Słowo kluczowe static</h1>

    <div class="note-subsection">
        <strong>Metody statyczne</strong>
        <pre><code>
            class SomeClass {
            public:
                static void sayHello() {
                    std::cout &lt;&lt; "hello";
                }
            };
                
            int main() {
                SomeClass::sayHello();
            }
        </code></pre>
    </div>

    <div class="note-subsection">
        <strong>Atrybuty statyczne</strong>
        <pre><code>
            class SomeClass {
            public:
                static int ktk;
            };
              
            // Ta definicja jest wymagana, inaczej program się nie skompiluje
            int SomeClass::ktk;
                
            int main() {
                // Wyświetli 0, bo zmienne statyczne są traktowane jak zmienne globalne i są inicjowane zerami
                std::cout &lt;&lt; SomeClass::ktk; 
            }
        </code></pre>
    </div>
</section>

<section class="note-section card card-body bg-light">
    <h1>Funkcje wirtualne i abstrakcyjne</h1>

    <div class="note-subsection">
        <strong>Jak definiować funkcje/klasy abstrakcyjne?</strong>
        <pre><code>
            class Figura {
            public:
                // Dzięki takiemu zapisowi, klasa Figura zostanie oflagowana jako abstrakcyjna
                virtual double obliczPole() = 0;
            };
        </code></pre>
    </div>
</section>

<section class="note-section card card-body bg-light">
    <h1>Wskaźniki na funkcje</h1>

    <pre><code>
        double add(double a, double b) {
            return a + b;
        }
        
        double substract(double a, double b) {
            return a - b;
        }
        
        int main() {
            double (*pointer)(double, double) = add;
            std::cout &lt;&lt; (*pointer)(10, 20); // wyświetli 30
        
            pointer = substract;
            std::cout &lt;&lt; (*pointer)(10, 20); // wyświetli -10
        }
    </code></pre>
</section>
</div>


    <script>hljs.highlightAll();</script>
    <script src="/assets/js/normalize-indents.js"></script>
    <script>
        $(document).on('click', '[data-toggle="lightbox"]', function(event) {
            event.preventDefault();
            $(this).ekkoLightbox();
        });
    </script>
    <script>
        MathJax = {
            chtml: { displayAlign: 'left' }
        };
    </script>
 </body>
</html>
