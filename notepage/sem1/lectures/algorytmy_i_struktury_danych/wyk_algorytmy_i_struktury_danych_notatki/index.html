<!DOCTYPE html>
 <html>
 <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <link rel="stylesheet" href="/notes/assets/css/libs/bootstrap.min.css" />
    <link rel="stylesheet" href="/notes/assets/css/libs/ekko-lightbox.css" />
    <link rel="stylesheet" href="/notes/assets/css/libs/highlight.min.css" />
    <link rel="stylesheet" href="/notes/assets/css/style.css" />

    <script src="/notes/assets/js/libs/jquery-3.6.0.min.js"></script>
    <script src="/notes/assets/js/libs/bootstrap.min.js"></script>
    <script src="/notes/assets/js/libs/ekko-lightbox.min.js"></script>
    <script src="/notes/assets/js/libs/highlight.min.js"></script>

    <!--MathJax-->
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async
            src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  
    <meta name="description" content=""/>
    <title>
        
            Algorytmy i struktury danych | Notatki z zajÄ™Ä‡
        
        Katalog notatek z informatyki stosowanej
    </title>
 </head>
 <body>
    <div class="container" id="main-container">
    <header class="note-section card card-body bg-light">
        <h1>Algorytmy i struktury danych (wykÅ‚ady, semester  1)</h1>
        
            <p style="color: gray; margin-bottom: 8px;">
                ProwadzÄ…cy: dr inÅ¼. MÅ›cisÅ‚aw Åšrutek
            </p>
        

        <nav>
            <ul class="nav nav-tabs">
                

                

                

                
        
                
                    <li class="nav-item">
                        <a class="nav-link active" href="/notes/notepage/sem1/lectures/algorytmy_i_struktury_danych/wyk_algorytmy_i_struktury_danych_notatki/">Notatki z zajÄ™Ä‡</a>
                    </li>
                
                    <li class="nav-item">
                        <a class="nav-link" href="/notes/notepage/sem1/lectures/algorytmy_i_struktury_danych/wyk_algorytmy_i_struktury_danych_info/">Pytania na zaliczenie</a>
                    </li>
                
                    <li class="nav-item">
                        <a class="nav-link" href="/notes/notepage/sem1/lectures/algorytmy_i_struktury_danych/wyk_algorytmy_i_struktury_danych_materialy/">Opracowania i materiaÅ‚y do nauki</a>
                    </li>
                
            </ul>
        </nav>
    
        <p style="margin-top: 20px;"><a href="/notes/">(&larr; powrÃ³t do strony gÅ‚Ã³wnej)</a></p>
    </header>

    <section class="note-section card card-body bg-light">
    <h1>Czym jest algorytm? ğŸ¤”</h1>

    <div class="note-subsection">
        <strong>Bardzo waÅ¼ne, definicja algorytmu:</strong><br />
        <em>MoÅ¼na jÄ… zapisaÄ‡ wÅ‚asnymi sÅ‚owami, ale musi byÄ‡ zachowany poniÅ¼szy sens:</em><br/>
        skoÅ„czony uporzÄ…dkowany ciÄ…g jasno zdefiniowanych czynnoÅ›ci koniecznych do wykonania pewnego zadania
    </div>

    <div class="note-subsection">
        <strong>Sposoby zapisu algorytmu:</strong><br />
        <ul>
            <li>jÄ™zyk naturalny</li>
            <li>pseudokod</li>
            <li>schemat blokowy</li>
            <li>jÄ™zyk programowania</li>
            <li>lista krokÃ³w</li>
        </ul>
    </div>

    <div class="note-subsection">
        <strong>PodziaÅ‚y algorytmÃ³w:</strong><br />
        <ul>
            <li>proste (liniowe) lub rozgaÅ‚Ä™zione</li>
            <li>rekurencyjne, iteracyjne</li>
        </ul>
    </div>

    <div class="note-subsection">
        <strong>Cechy algorymu:</strong><br />
        <ul>
            <li>posiada pewne dane wejÅ›ciowe i dane wyjÅ›ciowe</li>
            <li>posiada zÅ‚oÅ¼onoÅ›Ä‡ (musi byÄ‡ w jakiÅ› sposÃ³b zÅ‚oÅ¼ony, jeÅ›li coÅ› przykÅ‚adowo tylko drukuje dane z wejÅ›cia na wyjÅ›cie, to nie jest algorytmem)</li>
            <li>skoÅ„czony (nie moÅ¼e wykonywaÄ‡ siÄ™ w nieskoÅ„czonoÅ›Ä‡!)</li>
            <li>okreÅ›lony deterministycznie [zawsze dla tego samego wejÅ›cia jest to samo wyjÅ›cie; brak losowoÅ›ci]</li>
        </ul>
    </div>
</section>

<section class="note-section card card-body bg-light">
    <h1>TrochÄ™ wstÄ™pnych informacji</h1>

    <div class="note-subsection">
        <strong>NaleÅ¼y znaÄ‡ pojÄ™cia:</strong><br />
        <ul>
            <li>LIFO (last in, first out)</li>
            <li>FIFO (first in, first out)</li>
        </ul>
    </div>

    <div class="note-subsection">
        <strong>Typy danych, ktÃ³re bÄ™dziemy uÅ¼ywaÄ‡ w algorytmach:</strong><br />
        <ul>
            <li>liczby (caÅ‚kowite, dziesiÄ™tne, dwÃ³jkowe)</li>
            <li>znaki (litery, ciÄ…gi liter)</li>
            <li>wskaÅºniki (wyznaczajÄ… adresy innych obiektÃ³w)</li>
        </ul>
    </div>

    <div class="note-subsection">
        <strong>Rodzaje pamiÄ™ci:</strong><br />
        <ul>
            <li>rejestry procesora</li>
            <li>pamiÄ™Ä‡ operacyjna (i plik wymiany)</li>
            <li>dyski twarde</li>
        </ul>
    </div>

    <div class="note-subsection">
        STRUKTURY DANYCH + ALGORYTMY = WYNIKI (rozwiÄ…zanie problemu)
    </div>

    <div class="note-subsection">
        <strong>WaÅ¼na uwaga:</strong>
        Informacje to nie to samo co dane!
    </div>

    <div class="note-subsection">
        <strong>Informatyka zajmuje siÄ™ informacjÄ…, ktÃ³ra:</strong>
        <ol>
            <li>przechowywana jest w strukturach danych</li>
            <li>przetwarzana za pomocÄ… algorytmÃ³w</li>
        </ol>
    </div>

</section>

<section class="note-section card card-body bg-light">
    <h1>Schemat blokowy</h1>

    <strong>Rodzaje blokÃ³w wystÄ™pujÄ…cych w schematach blokowych:</strong> <br />

    <a href="../img/bloki_w_schemacie_blokowym.png" data-toggle="lightbox">
        <img src="../img/bloki_w_schemacie_blokowym.png" class="note-img img-fluid" style="width: 250px;" />
    </a>

    <p><em>Uwaga prowadzÄ…cego: najlepiej rysowaÄ‡ schematy blokowe w taki sposÃ³b, aby miaÅ‚y jeden poczÄ…tek i jeden koniec (aby nie byÅ‚o kilku blokÃ³w koÅ„czÄ…cych)</em></p>
</section>

<section class="note-section card card-body bg-light">
    <h1>Liczby zespolone</h1>

    <div class="note-subsection">
        <a href="../img/delta_w_liczbach_zespolonych.png" data-toggle="lightbox">
            <img src="../img/delta_w_liczbach_zespolonych.png" class="note-img img-fluid" style="width: 360px;" />
        </a>
    </div>

    <div class="note-subsection">
        <strong>Algorytm liczenia rÃ³wnania kwadratowego (razem z wynikami zespolonymi):</strong><br />
        <a href="../img/liczenie_delty_schemat_blokowy.jpg" data-toggle="lightbox">
            <img src="../img/liczenie_delty_schemat_blokowy.jpg" class="note-img img-fluid" style="width: 160px;" />
        </a>
    </div>
</section>

<section class="note-section card card-body bg-light">
    <h1>Struktury danych</h1>
    <ol>
        <li>Tablice jednowymiarowe (wektory)</li>
        <li>
            Tablice wielowymiarowe (macierze)<br />
            W macierzy najczÄ™Å›ciej pierwszym indeksem jest wiersz, drugim kolumna (tak jak na matematyce)
        </li>
        <li>
            Stos
            <ul>
                <li>DziaÅ‚a zgodnie z zasadÄ… LIFO</li>
                <li>Ma funkcje Push i Pop</li>
                <li>KaÅ¼dy element na stosie skÅ‚ada siÄ™ z przechowywanej zmiennej + wskaÅºnika przechowujÄ…cego kolejny element na stosie</li>
                <li>
                    Dodatkowe funkcje stosu:
                    <ol>
                        <li>Top â€“ przechowuje wskaÅºnik do szczytu stosu</li>
                        <li>PrzepeÅ‚nienie - dla stosu o zadeklarowanej maksymalnej wielkoÅ›ci</li>
                        <li>Stos pusty â€“ sprawdza czy stos jest pusty</li>
                    </ol>
                </li>
            </ul>
        </li>
        <li>
            Kolejka
            <ul>
                <li>DziaÅ‚a zgodnie z zasadÄ… FIFO</li>
                <li>Liniowa struktura danych</li>
                <li>Elementy pobieramy z poczÄ…tku</li>
                <li>Nowe elementy wstawiamy na koniec</li>
                <li>Pierwszy element nazywamy gÅ‚owÄ…, ostatni element nazywamy ogonem</li>
            </ul>
        </li>
        <li>
            Lista
            <ul>
                <li>Liniowa struktura danych</li>
                <li>Lista to ciÄ…g elementÃ³w, w ktÃ³rym kaÅ¼dy element pamiÄ™ta swojego nastÄ™pcÄ™ i poprzednika</li>
                <li>Pozwala wstawiaÄ‡ elementy w dowolnym miejscu</li>
                <li>Lista umoÅ¼liwia symulowanie zarÃ³wno kolejki, jak i stosu</li>
                <li>
                    Podstawowe funkcje listy:
                    <ul>
                        <li>Search(L, x) â€“ znajduje wskaÅºnik do elementu o kluczu x, bÄ…dÅº NULL jeÅ›li nie ma elementu z kluczem</li>
                        <li>Insert(L, x, w) â€“ wstawia element o kluczu x w miejscu wskazanym przez w</li>
                        <li>Delete(L, w) â€“ usuwa element wskazywany przez w</li>
                        <li>Min(L) â€“ zwraca element o najmniejszym kluczu</li>
                        <li>Max(L) â€“ zwraca element o najwiÄ™kszym kluczu</li>
                    </ul>
                </li>
                <li>
                    "Zabawa w pociÄ…g"
                    <ul>
                        <li>ListÄ™ moÅ¼na zobrazowaÄ‡ jako ciÄ…g osÃ³b trzymajÄ…cych siÄ™ za rÄ™ce. KaÅ¼da osoba trzyma swojego lewego i prawego sÄ…siada</li>
                        <li>W takiej strukturze moÅ¼liwe jest dodawanie nowej osoby w dowolnym miejscu</li>
                        <li>MoÅ¼liwe jest teÅ¼ usuwanie osÃ³b z takiej listy (pociÄ…gu)</li>
                        <li>WaÅ¼ne jest wtedy, aby sÄ…siedzi uwzglÄ™dnili zmianÄ™ i poprawili uchwyt rÄ…k</li>
                    </ul>
                </li>
            </ul>
        </li>
        <li>
            Drzewo binarne
            <ul>
                <li>
                    WÄ™zeÅ‚ reprezentowany za pomocÄ… rekordÃ³w:
                    <ol>
                        <li>klucz wÄ™zÅ‚a</li>
                        <li>wskaÅºnik do ojca</li>
                        <li>wskaÅºnik do lewego syna</li>
                        <li>wskaÅºnik do prawego syna</li>
                    </ol>
                </li>
                <li>
                    Drzewo binarne ma korzeÅ„ (wierzchoÅ‚ek) i liÅ›cie
                </li>
                <li>â€Drzewo regularneâ€ to takie, w ktÃ³rym kaÅ¼dy element ma albo 2 synÃ³w, albo 0</li>
            </ul>
        </li>
        <li>
            Kopiec (sterta, stÃ³g, ang. heap)
            <ul>
                <li>
                    szczegÃ³lny rodzaj drzewa, w ktÃ³rym wartoÅ›ci potomkÃ³w wÄ™zÅ‚a sÄ… w staÅ‚ej relacji z wartoÅ›ciÄ… rodzica (najczÄ™Å›ciej wiÄ™kszosÄ‡/mniejszoÅ›Ä‡)
                </li>
                <li>
                    na przykÅ‚ad moÅ¼e wystÄ™powaÄ‡ relacja, Å¼e syn ma zawsze wartoÅ›Ä‡ mniejszÄ… od ojca
                </li>
            </ul>
        </li>
        <li>
            Rekord
            <ul>
                <li>Struktura danych typowa dla baz danych</li>
                <li>Struktura w ktÃ³rej moÅ¼na przechowywaÄ‡ zmienne dowolnego typu (tzw. pola)</li>
                <li>Rekord powinien przechowywaÄ‡ dane na temat tego samego obiektu</li>
                <li>
                    PrzykÅ‚adowy rekord:
                    <ul>
                        <li>REKORD STUDENT</li>
                        <li>POLA IMIE, NAZWISKO, NR_INDEKSU, KIERUNEK, SEMESTR, WYDZIAÅ</li>
                    </ul>
                </li>
            </ul>
        </li>
    </ol>
</section>

<section class="note-section card card-body bg-light">
    <h1>ZÅ‚oÅ¼onoÅ›Ä‡ obliczeniowa algorytmÃ³w</h1>

    <div class="note-subsection">
        <strong>WÅ‚aÅ›ciwoÅ›ci idealnego algorytmu:</strong><br />
        <ul>
            <li>prosty kod</li>
            <li>Å‚atwy do zrozumienia</li>
            <li>moÅ¼e byÄ‡ napisany w kaÅ¼dym jÄ™zyku programowania</li>
            <li>liczy siÄ™ szybko</li>
            <li>potrzebuje niewiele pamiÄ™ci</li>
            <li>zawsze daje poprawne wyniki</li>
        </ul>
        <p>Przy czym trzeba pamiÄ™taÄ‡, Å¼e idealny algorytm nie istnieje :)</p>
    </div>
    
    <div class="note-subsection">
        <strong>Koszt algorytmu</strong>
        <ul>
            <li>
                pamiÄ™Ä‡
                <ul>
                    <li>liczba zmiennych</li>
                    <li>iloÅ›Ä‡ miejsca potrzebna dla danych</li>
                </ul>
            </li>
            <li>
                czas
                <ul>
                    <li>liczba instrukcji</li>
                    <li>liczba operacji arytmetycznych</li>
                    <li>liczba wywoÅ‚aÅ„ procedury</li>
                </ul>
            </li>
        </ul>
        <p>NajczÄ™Å›ciej bardziej skomplikowany algorytm moÅ¼e byÄ‡ albo szybki, albo zajmowaÄ‡ maÅ‚o pamiÄ™ci - trudno pogodziÄ‡ oba :(</p>
    </div>

    <div class="note-subsection">
        <strong>ZÅ‚oÅ¼onoÅ›Ä‡ czasowa (zÅ‚oÅ¼onoÅ›Ä‡ obliczeniowa)</strong>
        <p>ZÅ‚oÅ¼onoÅ›Ä‡ czasowa to iloÅ›Ä‡ czasu niezbÄ™dnego do rozwiÄ…zania problemu w zaleÅ¼noÅ›ci od liczby danych wejÅ›ciowych.</p>
        <p>ZÅ‚oÅ¼onoÅ›Ä‡ czasowa jest zatem pewnÄ… funkcjÄ…, ktÃ³ra jako argument przyjmuje liczbÄ™ danych wejÅ›ciowych (n), na przykÅ‚ad T(n) = 2n<sup>2</sup> + n + 5</p>
        <p>ZÅ‚oÅ¼onoÅ›Ä‡ czasowÄ… wyraÅ¼amy albo w jednostkach czasu, albo w liczbie operacji, ktÃ³re naleÅ¼y wykonaÄ‡ dla n danych, aby otrzymaÄ‡ rozwiÄ…zanie problemu. Zwykle uÅ¼ywamy liczby operacji, rzadziej czasu.</p>
        <p style="font-style: italic;">LiczÄ…c liczbÄ™ operacji w schemacie blokowym, zwykle pomijamy: instrukcje stopu i startu, instrukcje wejÅ›cia/wyjÅ›cia</p>
    </div>

    <div class="note-subsection">
        <strong>ZÅ‚oÅ¼onoÅ›Ä‡ pamiÄ™ciowa</strong>
        <p>ZÅ‚oÅ¼onoÅ›Ä‡ pamiÄ™ciowa to liczba komÃ³rek pamiÄ™ci, ktÃ³ra bÄ™dzie zajÄ™ta przez dane i wyniki poÅ›rednie tworzone w trakcie pracy algorytmu. WyraÅ¼amy jÄ… zwykle w bajtach <span style="font-style: italic;">(obliczajÄ…c to na zaliczeniu trzeba samemu wybraÄ‡ ile bajtÃ³w bÄ™dÄ… zajmowaÄ‡ poszczegÃ³lne zmienne)</span>.</p>
    </div>

    <div class="note-subsection">
        <strong>Trzy postacie zÅ‚oÅ¼onoÅ›ci:</strong>
        <ul>
            <li>zÅ‚oÅ¼onoÅ›Ä‡ minimalna (optymistyczna) - dla najbardziej korzystnego zestawu danych</li>
            <li>zÅ‚oÅ¼onoÅ›Ä‡ Å›rednia - zuÅ¼ycie zasobÃ³w dla typowych (losowych) danych</li>
            <li>zÅ‚oÅ¼onoÅ›Ä‡ maksymalna (pesymistyczna) - dla najbardziej niekorzystnego zestawu danych</li>
        </ul>
    </div>
</section>

<section class="note-section card card-body bg-light">
    <h1>Sortowanie przez wstawianie</h1>

    <div class="note-subsection">
        <strong>Sortowanie przez wstawianie (insertion sort)</strong>
        <p>Sortowanie jest podobne do ukÅ‚adania kart pobieranych z talii.</p>
        <p>Bierzemy pierwszÄ… kartÄ™ z talii.</p>
        <p>Pobieramy kolejne, aÅ¼ do wyczerpania talii.</p>
        <p>KaÅ¼dÄ… pobranÄ… kartÄ™ porÃ³wnujemy z kartami, ktÃ³re juÅ¼ trzymamy w rÄ™ce i szukamy dla niej miejsca przed pierwszÄ… kartÄ… starszÄ…. Gdy znajdziemy takie miejsce, rozsuwamy karty i nowÄ… wstawiamy na przygotowane w ten sposÃ³b miejsce. JeÅ¼eli nasza karta jest najstarsza (najmÅ‚odsza), to umieszczamy jÄ… na samym koÅ„cu.</p>
    </div>

    <div class="note-subsection">
        <strong>PrzykÅ‚adowa implementacja algorytmu (w Pythonie)</strong>
        <pre><code>
            from random import randrange

            list_size = 10
            my_list = [randrange(1, 100) for _ in range(1, list_size + 1)]

            for i in range(1, list_size):
                for j in reversed(range(0, i)):
                    if my_list[j+1] &lt; my_list[j]:
                        my_list[j+1], my_list[j] = my_list[j], my_list[j+1]
        </code></pre>
    </div>

    <!--<div class="note-subsection">
        <strong>Sortowanie przez wybÃ³r (selection sort)</strong>
    </div>

    <div class="note-subsection">
        <strong>Sortowanie przez zamianÄ™ (exchange sort)</strong>
    </div>-->

</section>

<section class="note-section card card-body bg-light">
    <h1>Sortowanie przez wybÃ³r</h1>

    <div class="note-subsection">
        <strong>Sortowanie przez wybÃ³r (selection sort)</strong>
        <ol>
            <li>Szukamy w zbiorze elementu najmniejszego i wymieniamy go z elementem na pierwszej pozycji.</li>
            <li>ZnÃ³w wyszukujemy element najmniejszy i wymieniamy go z elementem na drugiej pozycji.</li>
            <li>I tak dla kaÅ¼dego elementu.</li>
        </ol>
    </div>

    <div class="note-subsection">
        <strong>PrzykÅ‚adowa implementacja algorytmu (w Pythonie)</strong>
        <pre><code>
            from random import randrange

            list_size = 10
            my_list = [randrange(1, 100) for _ in range(1, list_size + 1)]

            for i in range(0, list_size):
                min_index, min_value = i, my_list[i]
                for j in range(i + 1, list_size):
                    if my_list[j] &lt; min_value:  # aby zrobiÄ‡ sortowanie malejÄ…ce, zmieniamy tu znak na &gt;
                        min_index, min_value = j, my_list[j]
                my_list[i], my_list[min_index] = my_list[min_index], my_list[i]
        </code></pre>
    </div>
</section>

<section class="note-section card card-body bg-light">
    <h1>Sortowanie przez zamianÄ™</h1>

    <div class="note-subsection">
        <strong>Sortowanie bÄ…belkowe (bubble sort)</strong>
        <ol>
            <li>Jest to sztandarowy przykÅ‚ad algorytmu dziaÅ‚ajÄ…cego "przez zamianÄ™".</li>
            <li>Polega na stopniowym zamienianiu miejscami sÄ…siadujÄ…cych elementÃ³w, tak dÅ‚ugo aÅ¼ zbiÃ³r danych zostanie posortowany.</li>
        </ol>
    </div>

    <div class="note-subsection">
        <strong>PrzykÅ‚adowa implementacja algorytmu (w Pythonie)</strong>
        <pre><code>
            from random import randrange

            list_size = 100
            my_list = [randrange(1, 100) for _ in range(1, list_size + 1)]

            for i in range(0, list_size - 1):
                for j in range(0, list_size - i - 1):
                    if my_list[j] > my_list[j + 1]:
                        my_list[j], my_list[j + 1] = my_list[j + 1], my_list[j]
        </code></pre>
    </div>

    <div class="note-subsection">
        <strong>Ulepszona implementacja algorytmu</strong>
        <pre><code>
            from random import randrange

            list_size = 100
            my_list = [randrange(1, 100) for _ in range(1, list_size + 1)]

            for i in range(0, list_size - 1):
                has_swapped = False
                for j in range(0, list_size - i - 1):
                    if my_list[j] > my_list[j + 1]:
                        my_list[j], my_list[j + 1] = my_list[j + 1], my_list[j]
                        has_swapped = True
                if not has_swapped:
                    break
        </code></pre>
    </div>
</section>

<section class="note-section card card-body bg-light">
    <h1>Sortowanie - c.d.</h1>

    <div class="note-subsection">
        <strong>Inne algorytmy</strong>
        <ul>
            <li>
                Quick sort
                <ul>
                    <li>algorytm zrealizowany na podstawie reguÅ‚y "dziel i zwyciÄ™Å¼aj"</li>
                    <li>stopniowo dzielimy tablicÄ™ na dwie mniejsze czÄ™Å›ci, w kaÅ¼dej czÄ™Å›ci przenoszÄ…c liczby wiÄ™ksze i mniejsze na jednÄ… ze stron</li>
                    <li>w procesie przenoszenia, Å›rodkowy element nazywamy "pivotem"</li>
                </ul>
            </li>
            <li>
                Shell sort
                <ul>
                    <li>Autor algorytmu zauwaÅ¼yÅ‚, Å¼e algorytmy sortowania "przez zamianÄ™" dziaÅ‚ajÄ… lepiej, gdy przekazujemy im do posortowania zbiÃ³r wzglÄ™dnie posortowany.</li>
                    <li>Sortowany zbiÃ³r dzielimy na mniejsze podzbiory, w ktÃ³rych kaÅ¼dy element jest oddalony od innego o rÃ³wnÄ… odlegÅ‚oÅ›Ä‡. PowstaÅ‚e zbiory sortujemy sortowaniem przez zamianÄ™.</li>
                    <li>NastÄ™pnie tworzymy nowe zbiory, zmniejszajÄ…c odlegÅ‚oÅ›Ä‡ miÄ™dzy elementami - a p potem rÃ³wnieÅ¼ sortujemy je "przez zamianÄ™"</li>
                    <li>Powtarzamy to tak dÅ‚ugo, aÅ¼ odlegÅ‚oÅ›Ä‡ pomiÄ™dzy poszczegÃ³lnymi elementami podzbiorÃ³w nie wyniesie 1.</li>
                </ul>
            </li>
            <li>Sortowanie drzewiaste/stogowe</li>
        </ul>
    </div>
</section>

<section class="note-section card card-body bg-light">
    <h1>Algorytmy iteracyjne &amp; algorytmy rekurencyjne</h1>

    <div class="note-subsection">
        <strong>Algorytm rekurencyjny</strong>
        <p>Algorytm rekurencyjny polega na tym, Å¼e obiekt skÅ‚ada siÄ™ czÄ™Å›ciowo z samego siebie.</p>
    </div>

    <div class="note-subsection">
        <strong>Algorytm iteracyjny</strong>
        <p>Algorytm iteracyjny to taki, w ktÃ³rym zastosowano pÄ™tle.</p>
    </div>

    <div class="note-subsection">
        <strong>Problem skoczka szachowego</strong>
        <p>PrzykÅ‚adowy problem, ktÃ³ry moÅ¼na rozwiÄ…zaÄ‡ rekurencjÄ…. Trzeba znaleÅºÄ‡ takÄ… Å›cieÅ¼kÄ™ dla skoczka szachowego, aby odwiedziÅ‚ on kaÅ¼de pole - oraz aby kaÅ¼de pole odwiedzone zostaÅ‚o tylko jeden raz.</p>
        <img src="../img/problem_skoczka.gif" alt="problem skoczka - gif" class="img-fluid" />
    </div>

    <div class="note-subsection">
        <strong>Problem oÅ›miu hetmanÃ³w</strong>
        <p>PrzykÅ‚adowy problem, ktÃ³ry moÅ¼na rozwiÄ…zaÄ‡ rekurencjÄ…. Trzeba w taki sposÃ³b rozstawiÄ‡ 8 hetmanÃ³w na planszy szachowej, aby Å¼aden z nich nie mÃ³gÅ‚ zbiÄ‡ innego.</p>
        <img src="../img/osiem_hetmanow.png" alt="problem 8 hetmanÃ³w" class="img-fluid" />
    </div>
</section>

<section class="note-section card card-body bg-light">
    <h1>Grafy</h1>
    
    <div class="note-subsection">
        <strong>Czym jest graf?</strong>
        <p>Graf â€“ struktura skÅ‚adajÄ…ca siÄ™ z wierzchoÅ‚kÃ³w (oznaczanych V) i gaÅ‚Ä™zi miÄ™dzy nimi (oznaczanych E).</p>
        <p>WaÅ¼ne! Graf nie jest algorytmem!</p>
        <img src="../img/graf.png" alt="grafik" class="img-fluid" />
    </div>

    <div class="note-subsection">
        <strong>Rodzaje grafÃ³w</strong>
        <ul>
            <li>Graf nieskierowany â€“ gaÅ‚Ä™zie sÄ… dwukierunkowe</li>
            <li>Graf skierowany â€“ gaÅ‚Ä™zie sÄ… jednokierunkowe</li>
        </ul>
    </div>

    <div class="note-subsection">
        <strong>Cykl i Å›cieÅ¼ka Eulera</strong>
        <ul>
            <li>Graf Eulera (eulerowski) to taki graf, w ktÃ³rym moÅ¼na skonstruowaÄ‡ cykl Eulera.</li>
            <li>Cykl Eulera to cykl, ktÃ³ry przechodzi przez kaÅ¼dÄ… krawÄ™dÅº grafu dokÅ‚adnie raz i wraca do punktu wyjÅ›ciowego.</li>
            <li>ÅšcieÅ¼ka Eulera to Å›cieÅ¼ka przechodzÄ…ca przez kaÅ¼dÄ… krawÄ™dÅº dokÅ‚adnie raz (ale niekoniecznie wracajÄ…ca do punktu wyjÅ›cia).</li>
            <li>Aby daÅ‚o siÄ™ skonstruowaÄ‡ cykl Eulera wszystkie wierzchoÅ‚ki muszÄ… mieÄ‡ parzysty stopieÅ„, a Å¼eby daÅ‚o siÄ™ skonstruowaÄ‡ Å›cieÅ¼kÄ™ Eulera - wszystkie za wyjÄ…tkiem co najwyÅ¼ej dwÃ³ch.</li>
        </ul>
    </div>

    <div class="note-subsection">
        <strong>Cykl i Å›cieÅ¼ka Hamiltona</strong>
        <ul>
            <li>Cykl Hamiltona to cykl, ktÃ³ry przechodzi przez kaÅ¼dy wierzchoÅ‚ek grafu dokÅ‚adnie raz i wraca do punktu wyÅ›ciowego.</li>
            <li>ÅšcieÅ¼ka Hamiltona to Å›cieÅ¼ka, ktÃ³ra przechodzi przez kaÅ¼dy wierzchoÅ‚ek grafu dokÅ‚adnie raz (ale niekoniecznie wracajÄ…ca do punktu wyjÅ›ciowego).</li>
            <li>Badaniem minimalnego cyklu Hamiltona dla grafu waÅ¼onego zajmuje siÄ™ <strong>problem komiwojaÅ¼era.</strong></li>
        </ul>
    </div>

    <div class="note-subsection">
        <strong>Dwa sposoby rozwiÄ…zania problemu komiwojaÅ¼era</strong>
        <ul>
            <li>DokÅ‚adny - polega na porÃ³wnaniuze sobÄ… kaÅ¼dej moÅ¼liwej Å›cieÅ¼ki; bardzo trudny w realizacji, bo w przypadku wiÄ™kszej iloÅ›ci miast trzeba bÄ™dzie wykonaÄ‡ gigantycznÄ… liczbÄ™ porÃ³wnaÅ„</li>
            <li>
                Heurystyczny - algorytmy o wiele szybsze, ale dajÄ…ce mniej dokÅ‚adny wynik
                <ul>
                    <li>minimalne drzewo rozpinajÄ…ce</li>
                    <li>najbliÅ¼szy sÄ…siad</li>
                </ul>
            </li>
        </ul>
    </div>

    <div class="note-subsection">
        <strong>PojÄ™cia zwiÄ…zane z grafami</strong>
        <ul>
            <li>JeÅ›li krawÄ™dÅº Å‚Ä…czy dwa wierzchoÅ‚ki, to jest z nimi <strong>incydentna</strong>. W grafach skierowanych rozrÃ³Å¼nia siÄ™ poczÄ…tkowy i koÅ„cowy wierzchoÅ‚ek krawÄ™dzi.</li>
            <li><strong>PÄ™tla wÅ‚asna</strong> - krawÄ™dÅº Å‚Ä…czÄ…ca wierzchoÅ‚ek z samym sobÄ…</li>
            <li><strong>ÅšcieÅ¼ka lub droga</strong> - (w grafie skierowanym) sekwencja krawÄ™dzi taka, Å¼e koniec jednej krawÄ™dzi jest poczÄ…tkiem nastÄ™pnej</li>
            <li><strong>StopieÅ„ wierzchoÅ‚ka</strong> to liczba wychodzÄ…cych z niego krawÄ™dzi.</li>
            <li><strong>StopieÅ„ grafu</strong> to najwyÅ¼szy stopieÅ„ wierzchoÅ‚ka wystÄ™pujÄ…cy w danym grafie. .</li>
            <li><strong>Graf regularny</strong> stopnia r to graf w ktÃ³rym wszystkie wierzchoÅ‚ki majÄ… stopieÅ„ r.</li>
            <li><strong>DÅ‚ugoÅ›ciÄ… Å›cieÅ¼ki</strong> nazywamy liczbÄ™ naleÅ¼Ä…cych do niej krawÄ™dzi</li>
        </ul>
    </div>

    <div class="note-subsection">
        <strong>Metody zapisu grafu w pamiÄ™ci komputera</strong>
        <ul>
            <li>
                <strong>lista sÄ…siedztwa</strong>
                <p>wypisujemy listÄ™ wierzchoÅ‚kÃ³w, oraz jakie wierzchoÅ‚ki sÄ… do nich poÅ‚Ä…czone</p>
            </li>
            <li>
                <strong>macierz sÄ…siedztwa</strong>
                <p>macierz o wymiarze liczba_wierzchoÅ‚kÃ³w x liczba_wierzchoÅ‚kÃ³w</p>
                <p>na przeciÄ™ciu dajemy 1 jeÅ›li sÄ… poÅ‚Ä…czone i 0 jeÅ›li nie sÄ…</p>
            </li>
            <li>
                <strong>lista krawÄ™dzi</strong>
                <p>wypisujemy po kolei jakie mamy krawÄ™dzie</p>
            </li>
            <li>
                <strong>macierz incydencji</strong> [przy grafach skierowanych]
                <p>macierz o wymiarze V*E </p>
                <p>jeÅ›li krawÄ™dÅº wychodzi z danego wierzchoÅ‚ka, to w odpowiedniej kolumnie wpisuje siÄ™ -1</p>
                <p>jeÅ›li do niego wchodzi +1</p>
                <p>jeÅ›li wierzchoÅ‚ek nie jest poÅ‚Ä…czony 0</p>
                <p>jeÅ›li to pÄ™tla wÅ‚asna, 2</p>
            </li>
        </ul>
    </div>

    <div class="note-subsection">
        <strong>Metody przeszukiwania grafÃ³w</strong>
        <ul>
            <li>
                <strong>metoda wzdÅ‚uÅ¼</strong>
                <p>algorytm przechodzi <strong>wybranÄ… Å›cieÅ¼kÄ…</strong> aÅ¼ do jej caÅ‚kowitego wyczerpania</p>
                <p>domyÅ›lnie wszystkie wierzchoÅ‚ki majÄ… status â€nieodwiedzonyâ€, a dziaÅ‚anie algorytmu stopniowo nadaje wierzchoÅ‚kom status â€odwiedzonyâ€.</p>
            </li>
            <li>
                <strong>metoda wszerz</strong>
                <p>procedura porusza siÄ™ wszerz grafu, aby odwiedziÄ‡ wszystkich nieodwiedzonych sÄ…siadÃ³w (tworzy jakby gwiazdÄ™)</p>
            </li>
        </ul>
    </div>
</section>

<section class="note-section card card-body bg-light">
    <h1>Algorytmy ktÃ³re trzeba znaÄ‡</h1>
    
    <div class="note-subsection">
        <strong>Algorytm dijkstry</strong>
        <p>Algorytm szukania "najkrÃ³tszej Å›cieÅ¼ki" pomiÄ™dzy punktem poczÄ…tkowym a koÅ„cowym. Przez najkrÃ³tszÄ… Å›cieÅ¼kÄ™ rozumie siÄ™ takÄ… Å›cieÅ¼kÄ™, ktÃ³rej suma wag jest moÅ¼liwie jak najniÅ¼sza.</p>
        <img src="../img/dijkstra.gif" alt="dijkstra" class="img-fluid" />
        <p>Jego matematyczny zapis polega na przeanalizowaniu kaÅ¼dego wierzchoÅ‚ka - przesuwajÄ…c siÄ™ wzdÅ‚uÅ¼ grafu kaÅ¼demu wierzchoÅ‚kowi przypisujemy liczbÄ™ oznaczajÄ…cÄ… aktualny koszt dotarcia do tego wierzchoÅ‚ka. Na koÅ„cu naleÅ¼y na podstawie tych wyznaczonych liczb odczytaÄ‡ wÅ‚aÅ›ciwÄ… Å›cieÅ¼kÄ™.</p>
    </div>

    <div class="note-subsection">
        <strong>WieÅ¼e Hanoi</strong>
        <p>SÄ… trzy drÄ…Å¼ki, trzeba przenieÅ›Ä‡ krÄ…Å¼ki z drÄ…Å¼ka 1 na drÄ…Å¼ek 3.</p>
        <p>Nie moÅ¼na braÄ‡ wiÄ™cej niÅ¼ jednego krÄ…Å¼ka na raz, nie moÅ¼na kÅ‚aÅ›Ä‡ maÅ‚ego na duÅ¼y.</p>
        <img src="../img/hanoi.png" alt="hanoi.png" class="img-fluid" />
    </div>
</section>
</div>


    <script>hljs.highlightAll();</script>
    <script src="/notes/assets/js/normalize-indents.js"></script>
    <script>
        $(document).on('click', '[data-toggle="lightbox"]', function(event) {
            event.preventDefault();
            $(this).ekkoLightbox();
        });
    </script>
    <script>
        MathJax = {
            chtml: { displayAlign: 'left' }
        };
    </script>
 </body>
</html>
